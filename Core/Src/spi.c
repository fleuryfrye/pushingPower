
#include "spi.h"
#include <string.h>
#include <stdlib.h>
#include "stm32f3xx_hal.h"
#include "piezo.h"
#include "timer.h"


volatile uint16_t rxBuffer[MESSAGE_LEN] = {};

uint8_t msgLength = 0;


volatile uint8_t messageReceived = 0;

volatile uint8_t processLength = 0;
uint8_t msg[MESSAGE_LEN] = {};

extern outputCharacteristics_t waveform;






void initSPI(void)
{
	//Need to turn on peripheral clock for SPI
	RCC->APB2ENR |= (SPI1_APB2_ENABLE);


	// Since SPI is in slave mode, we have no output.
	// MISO is disabled.
	// MOSI receives data while NSS (SPI_CS) is active.
	// CLK is generated by user and received as an input.

	//On NUCELO dev board:
	// MOSI: D11 (PB5)
	// NSS:  D10 (PA11)
	// CLK:  D13 (PB3)

	// Pins are configured as inputs as reset state.


	//SPI is configured for 8 bit data frame in receive mode only.
	//RXNE interrupt triggered every byte of data received in the RX buffer.
	SPI1->CR1 |= (SPI_ENABLE | SPI_RX_ONLY);

	SPI1->CR2 |= (SPI_ENABLE_RX_INT | SPI_RX_FIFO_16_BIT_THRESHOLD | SPI_SET_DATA_SIZE_16_BIT);

	//Register RX interrupt with the NVIC
	NVIC_EnableIRQ(SPI1_IRQn);



}



void resetSPI(void)
{
	RCC->APB2RSTR |= (SPI1_APB2_ENABLE);
	wait(10);
	RCC->APB2RSTR &= ~(SPI1_APB2_ENABLE);

	memset(rxBuffer, 0, sizeof(rxBuffer));
	msgLength = 0;
	initSPI();
}



uint8_t SPI_Idle(void)
{
	return (readPin(GPIOA, NSS_PIN));
}



uint8_t validRequest(outputCharacteristics_t requestedWaveform)
{
	uint8_t valid = 1;

	uint16_t requestedAmplitude = requestedWaveform.amplitude;
	uint16_t requestedFrequency = requestedWaveform.frequency;


	if(requestedAmplitude < 0 || requestedAmplitude > 5000)
	{
		valid &= 0;
	}

	if(requestedFrequency < 0 || requestedFrequency > 20000)
	{
		valid &= 0;
	}

	return 1;

}


void processMessage(void)
{
	outputCharacteristics_t newWaveform = {VOLT, 0, 0, 0};
	uint8_t valid = 1;

	if((rxBuffer[0] & START_BIT) && (rxBuffer[1] & STOP_BIT))
	{
		uint8_t waveformBits = (rxBuffer[0] & ~START_BIT) >> WAVEFORM_BITS;

		switch(waveformBits)
		{
		case(VOLT):
				newWaveform.wave = VOLT;
				break;
		case(SINE):
				newWaveform.wave = SINE;
				break;

		case(RECTANGLE):
				newWaveform.wave = RECTANGLE;
				break;
		default:
				valid = 0;
			break;
		}


		newWaveform.amplitude = ( (rxBuffer[0] & ~START_BIT) & (rxBuffer[0] & ~(3 << WAVEFORM_BITS) ) );
		newWaveform.frequency = (rxBuffer[1] & ~(STOP_BIT));

		valid = validRequest(newWaveform);

	}
	else
	{
		valid = 0;
	}

	if(valid)
	{
		waveform = newWaveform;
		waveform.newRequest = 1;
	}



}


