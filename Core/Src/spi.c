
#include "spi.h"
#include "main.h"
#include <string.h>
#include <stdlib.h>


volatile uint8_t rxBuffer[RX_BUFFER_LENGTH] = {};

uint8_t msgLength = 0;


volatile uint8_t messageReceived = 0;

volatile uint8_t processLength = 0;
uint8_t msg[RX_BUFFER_LENGTH] = {};

extern outputCharacteristics_t waveform;




void initSPI(void)
{
	//Need to turn on peripheral clock for SPI
	RCC->APB2ENR |= (SPI1_APB2_ENABLE);


	// Since SPI is in slave mode, we have no output.
	// MISO is disabled.
	// MOSI receives data while NSS (SPI_CS) is active.
	// CLK is generated by user and received as an input.

	//On NUCELO dev board:
	// MOSI: D11 (PB5)
	// NSS:  D10 (PA11)
	// CLK:  D13 (PB3)

	// Pins are configured as inputs as reset state.


	//SPI is configured for 8 bit data frame in receive mode only.
	//RXNE interrupt triggered every byte of data received in the RX buffer.
	SPI1->CR1 |= (SPI_ENABLE | SPI_RX_ONLY);

	SPI1->CR2 |= (SPI_ENABLE_RX_INT | SPI_RX_FIFO_8_BIT_THRESHOLD | SPI_SET_DATA_SIZE);

	//Register RX interrupt with the NVIC
	NVIC_EnableIRQ(SPI1_IRQn);



}



void resetSPI(void)
{
	RCC->APB2RSTR |= (SPI1_APB2_ENABLE);
	wait(10);
	RCC->APB2RSTR &= ~(SPI1_APB2_ENABLE);

	memset(rxBuffer, 0, RX_BUFFER_LENGTH);
	msgLength = 0;
	initSPI();
}



uint8_t SPI_Idle(void)
{
	return (readPin(GPIOA, NSS_PIN));
}



uint8_t validRequest(outputCharacteristics_t requestedWaveform)
{
	uint8_t valid = 1;

	uint16_t requestedAmplitude = requestedWaveform.amplitude;
	uint16_t requestedFrequency = requestedWaveform.frequency;

	if(requestedWaveform.wave == NONE)
	{
		valid &= 0;
	}

	if(requestedAmplitude < 0 || requestedAmplitude > 5000)
	{
		valid &= 0;
	}

	if(requestedFrequency < 0 || requestedFrequency > 20000)
	{
		valid &= 0;
	}

	return valid;

}

void processMessage(void)
{
	outputCharacteristics_t requestedWaveform = {NONE, 0, 0, FALSE};

	char* tokenMsg = (char*)malloc(processLength * sizeof(char));
	memcpy(tokenMsg, msg, processLength);

    char *token = strtok(tokenMsg, ":");

    if(token != NULL)
    {
    	if(strcmp(token, "VOLT") == 0)
    	{
			requestedWaveform.wave = DC;
			token = strtok(NULL, ":");
    		if(token != NULL)
    		{
    			requestedWaveform.amplitude = my_atoi(token);
    		}
    	}

		else if(strcmp(token, "SIN") == 0)
		{
			requestedWaveform.wave = SINE;
			token = strtok(NULL, ":");
    		if(token != NULL)
    		{
    			requestedWaveform.amplitude = my_atoi(token);
				token = strtok(NULL, ":");
				if(token != NULL)
				{
					requestedWaveform.frequency = my_atoi(token);
				}
    		}
		}

		else if(strcmp(token, "RCT") == 0)
		{
			requestedWaveform.wave = SQUARE;
			token = strtok(NULL, ":");
    		if(token != NULL)
    		{
    			requestedWaveform.amplitude = my_atoi(token);
				token = strtok(NULL, ":");
				if(token != NULL)
				{
					requestedWaveform.frequency = my_atoi(token);
				}
    		}
		}

		else if(strcmp(token, "OFF") == 0)
		{
			requestedWaveform.wave = OFF;
			requestedWaveform.amplitude = 0;
			requestedWaveform.frequency = 0;
		}

    }


	if(validRequest(requestedWaveform))
	{
		waveform = requestedWaveform;
		waveform.newRequest = TRUE;
	}

    free(tokenMsg);
	return;
}

//ATOI algorithm created by ChatGPT. Stdlib atoi() was not working correctly.
//OpenAI, "Custom C implementation of the atoi algorithm," OpenAI ChatGPT, 2024. [Online]. Available: https://www.openai.com/chatgpt.
int my_atoi(const char *str) {
    int result = 0;      // To store the final integer value
    int sign = 1;        // To handle negative numbers
    int i = 0;           // Iterator index

    // Step 1: Skip leading whitespace
    while (str[i] == ' ' || str[i] == '\t' || str[i] == '\n' ||
           str[i] == '\v' || str[i] == '\f' || str[i] == '\r') {
        i++;
    }

    // Step 2: Check for optional '+' or '-' sign
    if (str[i] == '-') {
        sign = -1;
        i++;
    } else if (str[i] == '+') {
        i++;
    }

    // Step 3: Convert digits to integer
    while (str[i] >= '0' && str[i] <= '9') {
        result = result * 10 + (str[i] - '0');  // Accumulate the digit
        i++;
    }

    // Step 4: Return the result with the correct sign
    return result * sign;
}


